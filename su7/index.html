<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Su7</title>
    <link rel="stylesheet/less" type="text/css" href="css/su7.less">
    <link rel="stylesheet" href="css/dat.gui.css">
    <script src="js/less.js"></script>
    <script src="js/jquery-3.1.1.js"></script>
    <script src="js/gsap/gsap.min.js"></script>
    <script src="js/3d/dat.gui.js"></script>
</head>
<body>

<!-- loading相关 -->
<div class="loading-con">
    <div class="loading">
        <div class="loading-circle"></div>
        <div class="progress"></div>
    </div>
    <div class="loading-complete display-none">
        <p>
            加载完成
            <svg t="1677233206130" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2675" width="24" height="24"><path d="M537.6 102.4c73.5744 0 142.336 20.6848 200.704 56.576 15.872 9.6256 16.7936 23.1424 2.9696 40.5504-14.08 16.2816-43.008 13.2608-86.8352-9.216l-0.0512 0.0512a318.1568 318.1568 0 1 0 104.8064 524.3904h0.3584c19.456-26.7776 40.5504-40.192 63.1296-40.2432l6.8096 0.4096c24.064 4.4032 30.4128 16.6912 19.0464 36.864l0.2048-0.3584-0.1536 0.1536-0.0512 0.2048h-0.1024l-7.936 10.5984A384 384 0 1 1 537.6 102.4z m332.288 201.0112a33.28 33.28 0 0 1 0 47.104l-276.48 276.48a31.2832 31.2832 0 0 1-0.512 0.4608l-3.584 3.584a30.72 30.72 0 0 1-43.4176 0l-1.8432-1.792-0.4096-0.512-135.3216-135.2704a30.72 30.72 0 0 1 0-43.4176l3.584-3.584a30.72 30.72 0 0 1 43.4688 0l112.2304 112.128 255.232-255.1808a33.28 33.28 0 0 1 47.104 0z" fill="#ffffff" p-id="2676"></path></svg>
        </p>
    </div>
</div>

<section class="su7">
    <div class="su7-con"></div>

    <div class="buttons">
        <div class="button-item" id="tunnel">Tunnel</div>
        <div class="button-item" id="car-body">Body</div>
        <div class="button-item" id="wind-drag">Wind Drag</div>
        <div class="button-item" id="radar">雷达</div>
    </div>
</section>

<div class="dialog">
    <h3>请将设备横置</h3>
</div>
</body>

<script type="importmap">
    {
        "imports": {
                "three": "./js/3d/three.module.js"
        }
    }
</script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls }  from './js/3d/OrbitControls.js';
    import resources from "./js/config/resources.js";
    import Loader from './js/loaders/loadResource.js'
    import CameraShake from  './js/config/CameraShake.js'
    import DynamicEnv from  './js/config/DynamicEnv.js'
    import {vertexShader as vertexShaderSeep } from "./js/shaders/seep/vertex.js";
    import {fragmentShader as fragmentShaderSeep } from "./js/shaders/seep/fragment.js";

    const width = window.innerWidth;
    const height = window.innerHeight;
    const loader = new Loader()
    const buttonMap = {
        tunnel: '1',
        body: '2',
        windDrag: '3',
        radar: '4'
    }

    const elementSu7 = document.querySelector('.su7');
    const dialog = document.querySelector('.dialog');
    const scene = new THREE.Scene();
    const clock = new THREE.Clock();

    const radarVertexArray = [];
    const radarMeshArray = [];
    const vec3Zero = new THREE.Vector3(0,0.6,0)
    const group = new THREE.Group();
    const radarGroup = new THREE.Group();

    let fovDefault = 60;
    let fovTarget = 75;
    let curWheelRot = 0;
    let wheelRotSpeed = 0.4;
    let uSeep = 0.0;
    let buttonSelect = buttonMap.tunnel
    let isLandscapeScreen = false;
    let isIntoScene = false;
    let isRadar = false;
    let runTunnel = false;
    let isMouseDown = false;
    let nameToMeshDic = {};
    let loadMap = {};
    let  groundLoader, cubeRenderTarget, cubeCamera;

    const wheel = {
        wheel_back_right: null,
        wheel_back_left: null,
        wheel_front_right: null,
        wheel_front_left: null
    }

    const camera = new THREE.PerspectiveCamera( fovTarget, width / height, 0.1, 500 );
    camera.position.set( -0.1072,  1, -3.4973);
    camera.uIntensity = 0

    scene.background = new THREE.Color( 0x000000 );
    scene.fog = new THREE.Fog( 0x000000, 4, 40 );


    const renderTarget = new THREE.WebGLRenderTarget(width, height);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize( width, height );
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;
    $('.su7-con').append( renderer.domElement );


    window.addEventListener('resize', onWindowResized);

    cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
    cubeRenderTarget.texture.type = THREE.UnsignedByteType;
    cubeCamera = new THREE.CubeCamera(0.1, 200, cubeRenderTarget);

    // const gui = new GUI()
    // gui.add(cubeCamera.position, 'x', -10, 10)
    // gui.add(cubeCamera.position, 'y', -10, 10)
    // gui.add(cubeCamera.position, 'z', -10, 10)

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target = new THREE.Vector3(0, 1, 0);

    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    controls.enableZoom = false;

    controls.enablePan = false;

    controls.maxDistance = 3;
    controls.minDistance = 3;

    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI / 2;

    const cameraShake = new CameraShake();
    cameraShake.setIntensity(0);
    camera.cameraShakeIntensity = 0

    let envmap1,envmap2;
    let dynamicEnv

    loader.load(resources)

    loader.onFileLoaded((name,res) => {
        const result = loaderCustom(name)(res)
        if (!['sceneLoad','env_night','env_light'].includes(name)){
            scene.add(result)
        }
        loadMap[name] = result

        const value = loader.totalSuccess / loader.total * 100
        progressText(value)
    })

    loader.onLoadEnd(()=>{
        loadMap['roadMesh'].visible = false
        loadMap['otherCarLoad'].visible = false
        loadMap['cubeGround'].visible = false

        buttOnClick();

        setTimeout(()=>{
            if (envmap1 && envmap1){
                dynamicEnv = new DynamicEnv(renderer,{
                    envmap1,
                    envmap2,
                });
                // scene.background = dynamicEnv.envMap;
                scene.environment = dynamicEnv.envMap;
                dynamicEnv.setWeight(0);
            }

            intoScene()
        },1000)
    })

    function intoScene(){
        const loading_complete = document.querySelector('.loading-complete')
        const loading_con = document.querySelector('.loading-con')
        loading_complete.classList.remove("display-none");
        loading_con.classList.add("hide-loading");

        loading_con.addEventListener('animationend', function() {
            loading_con.classList.add("display-none")
        });
         nameToMeshDic['cameraFovTween'] = gsap.to(camera,{
            fov: fovDefault,
            uIntensity: 1,
            duration: 4,
            ease: 'power2.out',
            onUpdate:()=>{
                dynamicEnv.setIntensity(camera.uIntensity)
                dynamicEnv.setWeight(camera.uIntensity)
                nameToMeshDic['topLigt'].material.emissiveIntensity = camera.uIntensity
                camera.updateProjectionMatrix();
            }
        })
         nameToMeshDic['cameraDynTween'] = gsap.to(camera,{
            fov: fovDefault,
            uIntensity: 1,
            duration: 7,
            onUpdate:()=>{
                dynamicEnv.setIntensity(camera.uIntensity)
                dynamicEnv.setWeight(camera.uIntensity)
            }
        })

    }

    function updateLoadingProgress(progress,loading_text){
        progress && (progress.textContent = loading_text);
    }
    function progressText(percent){
        const text =  `加载场景模型: ${parseInt(percent)} %`
        const progress = document.querySelector('.progress')

        updateLoadingProgress(progress, text)

    }




    function buttOnClick(){
        const tunnel = document.getElementById('tunnel');
        const carBody = document.getElementById('car-body');
        const windDrag = document.getElementById('wind-drag');
        const radar = document.getElementById('radar');
        tunnel.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.tunnel
        }
        carBody.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.body
            const carCurve = nameToMeshDic['carCurve']
            loadMap['cubeGround'].visible = true

            gsap.to(carCurve.material.map.offset,{
                y: -2,
                duration: fovDefault,
                repeat: -1,
                ease: 'none'
            })
        }
        windDrag.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.windDrag

        }

        radar.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.radar
            isRadar = true;
            loadMap['roadMesh'].visible = true
            loadMap['otherCarLoad'].visible = true
            radarGroup.visible = true
            groundLoader.visible = false

            nameToMeshDic['cameraOutRadar'] && nameToMeshDic['cameraOutRadar'].kill()
            nameToMeshDic['controlsTween'] && nameToMeshDic['controlsTween'].kill()
            nameToMeshDic['cameraToRadar'] = gsap.to(camera.position,{
                x:  -3.74,
                y: 5.68,
                z: -0.10,
                duration: 1
            })
            nameToMeshDic['controlsTween'] = gsap.to(controls,{
                maxDistance: 6,
                minDistance: 6,
                duration: 1,
                repeat: 0,
                ease: 'none',
                onUpdate: () => {
                    camera.updateProjectionMatrix();
                }
            })
            setRadarMesh();
            setOtherCar();
        }
    }

    function carWheelForward(){
        const car = nameToMeshDic['car']
        carWheelToGsap(car,'wheel_front_left')
        carWheelToGsap(car,'wheel_front_right')
        carWheelToGsap(car,'wheel_back_left')
        carWheelToGsap(car,'wheel_back_right')
    }

    function carWheelStop(){
        const car = nameToMeshDic['car']
        carWheelStopGsap(car,'wheel_front_left')
        carWheelStopGsap(car,'wheel_front_right')
        carWheelStopGsap(car,'wheel_back_left')
        carWheelStopGsap(car,'wheel_back_right')
    }

    function carWheelToGsap(car,type){
        car.userData['tween_' + type] && car.userData['tween_' + type].kill()

        car.userData['tween_' + type] = gsap.to(wheel[type].rotation, {
            z: curWheelRot - 4 * Math.PI,
            duration: 1,
            ease: 'power1.in',
            onUpdate: () => {
                curWheelRot = wheel[type].rotation.z;
            },
            onComplete: () => {
                car.userData['tween_' + type].kill()
                car.userData['tween_' + type] = gsap.to(wheel[type].rotation, {
                    z: curWheelRot - 2 * Math.PI,
                    duration: wheelRotSpeed,
                    repeat: -1,
                    ease: 'none',
                });
            }
        });

    }

    function carWheelStopGsap(car,type){
        car.userData['tween_' + type] && car.userData['tween_' + type].kill()

        car.userData['tween_' + type] = gsap.to(wheel[type].rotation, {
            z: curWheelRot - 4 * Math.PI,
            duration: 2.0,
            ease: 'circ.out',
            onUpdate: () => {
                curWheelRot = wheel[type].rotation.z;
            },
            onComplete: () => {
                car.userData['tween_' + type].kill();
            }
        });

    }

    function loaderCustom(type){
        const StrategyMap = {
            'sceneLoad': (texture)=>{
                // scene.background = texture;
                // scene.environment = texture;
                // texture.mapping = THREE.EquirectangularReflectionMapping;
            },
            'env_night':(texture) =>{
                envmap1 = texture
            },
            'env_light':(texture) =>{
                envmap2 = texture
            },
            'roadMesh': (banMa)=>{
                banMa.wrapS = THREE.RepeatWrapping;
                banMa.wrapT = THREE.RepeatWrapping;
                banMa.repeat.set(1, 6);

                const PlaneGeometry =  new THREE.PlaneGeometry(100,15)
                const MeshStandardMaterial =  new THREE.MeshStandardMaterial({
                    map:banMa,
                    color: '#343434'
                })
                const roadMesh = new THREE.Mesh(
                    PlaneGeometry,
                    MeshStandardMaterial
                )
                roadMesh.rotation.x = - Math.PI / 2;
                roadMesh.position.y = -0.1;
                return roadMesh
            } ,
            'otherCarLoad': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if (['otherCar01','otherCar02'].includes(child.name)){
                        nameToMeshDic[child.name] = child
                        child.userData['originPos'] = child.position.clone();
                    }
                })
                return gltf.scene
            },
            'carLoad': (gltf)=>{
                nameToMeshDic['car'] = gltf.scene
                gltf.scene.traverse((child)=>{
                    if (['topLigt','radar','empennage'].includes(child.name)){
                        nameToMeshDic[child.name] = child
                    }
                    if (child.name === 'topLigt'){
                        child.material.emissiveIntensity = 0
                    }
                    if(['wheel_back_right','wheel_back_left','wheel_front_right','wheel_front_left'].includes(child.name)){
                        wheel[child.name] = child
                    }

                    if (child.name === '平面'){
                        child.material.envMap = cubeRenderTarget.texture;
                        child.material.normalMap = new THREE.TextureLoader().load('./img/t_floor_normal.webp')
                        child.material.roughnessMap = new THREE.TextureLoader().load('./img/t_floor_roughness.webp')

                        child.material.normalMap.flipY = false
                        child.material.normalMap.colorSpace = THREE.LinearSRGBColorSpace
                        child.material.normalMap.wrapS = THREE.RepeatWrapping
                        child.material.normalMap.wrapS = THREE.RepeatWrapping

                        child.material.roughnessMap.flipY = false
                        child.material.roughnessMap.colorSpace = THREE.LinearSRGBColorSpace
                        child.material.roughnessMap.wrapS = THREE.RepeatWrapping
                        child.material.roughnessMap.wrapS = THREE.RepeatWrapping

                        groundLoader = child
                    }

                    if (child.type === 'Mesh'){
                        // child.material.envMap = cubeRenderTarget.texture;
                        if (child.name !== '平面'){
                            child.material.envMapIntensity = 15;
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }

                })
                return gltf.scene
            },
            'carCurveLoad': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    nameToMeshDic['carCurve'] = child
                    if (child.name === 'xiedu'){
                        child.material.opacity = 0
                    }

                })
                return gltf.scene
            },
            'cubeGround': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if (child.name === 'cubeGround'){
                        nameToMeshDic[child.name] = child
                    }
                })
                return gltf.scene
            },
            'tunnelLoader': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    nameToMeshDic['tunnel'] = child
                    if (child.type === 'Mesh'){
                        // child.material.opacity = 0
                        child.material = new THREE.ShaderMaterial({
                            transparent: true,
                            side: THREE.DoubleSide,
                            vertexShader:vertexShaderSeep,
                            fragmentShader: fragmentShaderSeep,
                            uniforms: {
                                uOpacity: { value: 0.0 },
                                uSpeed: {value:  0.0 },
                                iTime: {value:  0.0 },
                            },
                        });
                        nameToMeshDic['tunnelOpacity'] = child
                    }
                })
                return gltf.scene
            },
        }
        return StrategyMap[type]
    }

    window.addEventListener('mousedown',(e)=>{
        if (!(e.target instanceof HTMLCanvasElement)){
            return
        }
        if (e.button === 0) {
            if (buttonSelect === buttonMap.tunnel){
                const tunnel = nameToMeshDic['tunnel']
                const car = nameToMeshDic['car']

                setTimeout(()=>{
                    car.traverse(child=>{
                        if (child.isMesh){
                            child.material.envMap = cubeRenderTarget.texture
                        }
                    })
                },100)


                runTunnel = true
                isMouseDown = true
                nameToMeshDic['topLigt'].visible = false
                nameToMeshDic['topLigt'].material.emissiveIntensity = 0
                nameToMeshDic['tunnelOpacity'].material.uniforms.iTime.value = 0.0


                nameToMeshDic['cameraTween'] && nameToMeshDic['cameraTween'].kill()
                nameToMeshDic['cameraFovTween'] && nameToMeshDic['cameraFovTween'].kill()
                nameToMeshDic['cameraDynTween'] && nameToMeshDic['cameraDynTween'].kill()
                nameToMeshDic['cameraShakeTween'] && nameToMeshDic['cameraShakeTween'].kill()
                tunnel.userData['tunnelTween'] && tunnel.userData['tunnelTween'].kill()
                car.userData['empennagePosTween'] &&  car.userData['empennagePosTween'].kill()
                car.userData['empennageRosTween'] &&  car.userData['empennageRosTween'].kill()

                nameToMeshDic['cameraTween'] = gsap.to(camera, {
                    fov: fovTarget,
                    cameraShakeIntensity: 1,
                    duration: 2,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });
                nameToMeshDic['cameraShakeTween'] = gsap.to(camera, {
                    cameraShakeIntensity: 1,
                    duration:4,
                    repeat: -1,
                    ease: "power2.out",
                    onUpdate:()=>{
                        camera.position.add(cameraShake.tweenedPosOffset);
                        cameraShake.setIntensity(camera.cameraShakeIntensity);
                        cameraShake.update();
                    }
                });

                tunnel.userData['tunnelTween'] = gsap.to(tunnel.material,{
                    opacity: 1,
                    duration: 3,
                    repeat: 0,
                    ease: "power2.out",
                    onUpdate: () => {
                        dynamicEnv.setIntensity(1 - tunnel.material.opacity)
                        uSeep = tunnel.material.opacity / 10
                        nameToMeshDic['tunnelOpacity'].material.uniforms.uOpacity.value = tunnel.material.opacity
                    }
                })

                car.userData['empennagePosTween'] = gsap.to(nameToMeshDic['empennage'].position,{
                    x: -0.42,
                    y: 236.14,
                    z: -107.97,
                    duration: 2,
                    repeat: 0,
                })
                car.userData['empennageRosTween'] = gsap.to(nameToMeshDic['empennage'].rotation,{
                    x: -0.189,
                    repeat: 0,
                    duration: 2,
                })

                carWheelForward()
            }
            if (buttonSelect === buttonMap.body) {
                const carCurve = nameToMeshDic['carCurve']
                loadMap['cubeGround'].visible = false

                nameToMeshDic['cameraTween'] && nameToMeshDic['cameraTween'].kill()
                carCurve.userData['carCurveOpacityTween'] && carCurve.userData['carCurveOpacityTween'].kill()
                carCurve.userData['carCurveOpacityTween'] = gsap.to(carCurve.material, {
                    opacity: 1,
                    repeat: 0,
                    duration: 4,
                    ease: 'none',
                });
                nameToMeshDic['cameraTween'] = gsap.to(camera, {
                    fov: fovTarget,
                    duration: 1,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });
            }
        }

    })
    window.addEventListener('mouseup',(e)=>{
        if (!(e.target instanceof HTMLCanvasElement)){
            return
        }
        if (e.button === 0){
            if (buttonSelect === buttonMap.tunnel){
                const tunnel = nameToMeshDic['tunnel']
                const car = nameToMeshDic['car']


                setTimeout(()=>{
                    car.traverse(child=>{
                        if (child.isMesh && child.name !== '平面'){
                            child.material.envMap = null
                        }
                    })
                },100)

                runTunnel = false
                nameToMeshDic['cameraTween'] && nameToMeshDic['cameraTween'].kill()
                nameToMeshDic['cameraShakeTween'] && nameToMeshDic['cameraShakeTween'].kill()
                car.userData['empennagePosTween'] &&  car.userData['empennagePosTween'].kill()
                car.userData['empennageRosTween'] &&  car.userData['empennageRosTween'].kill()
                tunnel.userData['tunnelTween'] &&  tunnel.userData['tunnelTween'].kill()

                nameToMeshDic['cameraTween'] = gsap.to(camera, {
                    fov: fovDefault,
                    duration: 2,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });
                tunnel.userData['tunnelTween'] = gsap.to(tunnel.material, {
                    opacity: 0,
                    repeat: 0,
                    duration: 1,
                    ease: 'none',
                    onUpdate: () =>{
                        if (tunnel.material.opacity < 0.5){
                            nameToMeshDic['topLigt'].visible = true
                            nameToMeshDic['topLigt'].material.emissiveIntensity = 1 - tunnel.material.opacity
                        }
                        dynamicEnv.setIntensity(1 - tunnel.material.opacity)
                        uSeep = tunnel.material.opacity / 10
                        nameToMeshDic['tunnelOpacity'].material.uniforms.uOpacity.value = tunnel.material.opacity
                    },
                    onComplete: ()=>{
                        isMouseDown = false
                    }
                });
                car.userData['empennagePosTween'] = gsap.to(nameToMeshDic['empennage'].position,{
                    x: 0.735,
                    y: 230.15,
                    z: -97.55,
                    duration: 2,
                    repeat: 0,
                })
                car.userData['empennageRosTween'] = gsap.to(nameToMeshDic['empennage'].rotation,{
                    x: 0,
                    repeat: 0,
                    duration: 2,
                })

                carWheelStop()
            }

            if (buttonSelect === buttonMap.body){
                const carCurve = nameToMeshDic['carCurve']

                nameToMeshDic['cameraTween'] && nameToMeshDic['cameraTween'].kill()
                carCurve.userData['carCurveOpacityTween'] && carCurve.userData['carCurveOpacityTween'].kill()
                carCurve.userData['carCurveOpacityTween'] = gsap.to(carCurve.material, {
                    opacity: 0,
                    repeat: 0,
                    duration: 1,
                    ease: 'none',
                    onComplete:()=>{
                        loadMap['cubeGround'].visible = true
                    }
                });
                nameToMeshDic['cameraTween'] = gsap.to(camera, {
                    fov: fovDefault,
                    duration: 1,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });
            }
        }

    })
    window.addEventListener('scroll', () => {
        if (isElementInViewport(elementSu7) && isMobile()) {
            if (!isLandscapeScreen){
                dialog.classList.add('show-dialog')
            }else {
                dialog.classList.remove('show-dialog')
            }
        }else {
            dialog.classList.remove('show-dialog')
        }
    });
    window.addEventListener('orientationchange', function() {
        isLandscapeScreen = !(screen.orientation.angle === 90 || screen.orientation.angle === 270);
    });

    function recoverState(){
        nameToMeshDic['cameraToRadar'] && nameToMeshDic['cameraToRadar'].kill();
        nameToMeshDic['controlsTween'] && nameToMeshDic['controlsTween'].kill();

        isRadar = false;
        loadMap['roadMesh'].visible = false
        loadMap['otherCarLoad'].visible = false
        loadMap['cubeGround'].visible = false
        radarGroup.visible = false
        nameToMeshDic['cameraOutRadar'] = gsap.to(camera.position,{
            x: -0.25,
            y: 1,
            z: -3.49,
            duration: 1
        })
        nameToMeshDic['controlsTween'] = gsap.to(controls,{
            maxDistance: 3.5,
            minDistance: 3.5,
            duration: 1,
            repeat: 0,
            ease: 'power5.inOut',
            onUpdate: () => {
                camera.updateProjectionMatrix();
            }
        })
    }
    function setRadarMesh(){
        const child = nameToMeshDic['radar'];
        const boxGeo = new THREE.BoxGeometry(0.02,0.01,0.1);
        const positionAttributes = child.geometry.getAttribute('position');

        for (let i = 0; i< positionAttributes.count; i++){
            const vec3 = new THREE.Vector3();
            vec3.fromBufferAttribute(positionAttributes,i);
            radarVertexArray.push(vec3);
        }
        radarGroup.visible = true
        if (!radarMeshArray.length){
            scene.add(radarGroup);
            radarGroup.position.set(0, 0.4, 0);
            for (let k = 0; k < 6; k++){
                for (let i = 0; i< radarVertexArray.length; i++){
                    const boxMat = new THREE.MeshBasicMaterial({color: 0xffffff, depthTest: false});
                    const boxMesh = new THREE.Mesh(boxGeo,boxMat);
                    boxMesh.position.copy(radarVertexArray[i]);
                    boxMesh.visible = false;
                    radarGroup.add(boxMesh);

                    radarMeshArray.push(boxMesh);
                    boxMesh.lookAt(vec3Zero);
                    boxMesh.userData['originPos'] =  boxMesh.position.clone();
                    boxMesh.translateZ(-5);
                    boxMesh.userData['targetPos'] =  boxMesh.position.clone();
                    boxMesh.translateZ(5);

                    if (k === 0){
                        boxMesh.userData['delay'] = 0
                    }else if (k === 1){
                        boxMesh.userData['delay'] = 0.5
                    }else if (k === 2){
                        boxMesh.userData['delay'] = 1
                    }else if (k === 3){
                        boxMesh.userData['delay'] = 2
                    }else if (k === 4){
                        boxMesh.userData['delay'] = 2.5
                    }else if (k === 5){
                        boxMesh.userData['delay'] = 3
                    }
                }
                for (let j = 0; j< radarMeshArray.length; j++){
                    gsap.to(radarMeshArray[j].position,{
                        x: radarMeshArray[j].userData['targetPos'].x,
                        y: radarMeshArray[j].userData['targetPos'].y,
                        z: radarMeshArray[j].userData['targetPos'].z,
                        duration: 4,
                        delay: radarMeshArray[j].userData['delay'],
                        repeat: -1,
                        ease: 'none',
                        onStart:()=>{
                            radarMeshArray[j].visible = true;
                        }
                    })
                }
            }
        }
    }

    function setOtherCar(){
        const otherCar01 = nameToMeshDic['otherCar01'];
        const otherCar02 = nameToMeshDic['otherCar02'];

        otherCar01.userData['otherCar01Tween'] && otherCar01.userData['otherCar01Tween'].kill();
        otherCar01.userData['otherCar02Tween'] && otherCar01.userData['otherCar02Tween'].kill();

        gsap.to(loadMap['roadMesh'].material.map.offset,{
            x:loadMap['roadMesh'].material.map.offset.x - 1,
            duration: 3,
            repeat: -1,
            ease: 'none'
        })

        otherCar01.position.copy(otherCar01.userData['originPos']);
        otherCar01.userData['otherCar01Tween'] = gsap.to(otherCar01.position,{
            x: 20,
            duration: 9,
            repeat: -1
        })

        otherCar02.position.copy(otherCar02.userData['originPos']);
        otherCar01.userData['otherCar02Tween'] = gsap.to(otherCar02.position,{
            x: -20,
            duration: 10,
            repeat: -1
        })

    }

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }

    function isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        return (
            rect.top <= (window.innerHeight - 200 || document.documentElement.clientHeight -200)
        )
    }

    function isMobile() {
        const reg = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
        return reg.test(navigator.userAgent);
    }

    let temp01 = 0;
    let temp02 = 0;
    let meshScale = 0;
    let temp = 1.5
    function renderLoop(){
        if (groundLoader){
            groundLoader.visible = false;
            cubeCamera.position.copy(camera.position);
            cubeCamera.position.y *= -1;
            cubeCamera.update(renderer,scene);
            groundLoader.visible = true;
        }

        if ( nameToMeshDic['tunnelOpacity'] && isMouseDown){
            nameToMeshDic['tunnelOpacity'].material.uniforms.iTime.value+= uSeep
        }

        for (let i = 0; i < radarMeshArray.length; i++){
            temp01 = nameToMeshDic['otherCar01'].position.distanceTo(radarMeshArray[i].position);
            temp02 = nameToMeshDic['otherCar02'].position.distanceTo(radarMeshArray[i].position);

            if (temp01 < temp || temp02 < temp){
                radarMeshArray[i].material.color.setHex(0x00ff00);

                if (temp01 < temp){
                    meshScale = 3 - temp01 > 1 ? 3 - temp01 : 1;
                    radarMeshArray[i].scale.setZ(meshScale)
                }

                if (temp02 < temp){
                    meshScale = 3 - temp02 > 1 ? 3 - temp02 : 1;
                    radarMeshArray[i].scale.setZ(meshScale)
                }
            }else {
                radarMeshArray[i].material.color.setHex(0xffffff);
                radarMeshArray[i].scale.set(1, 1, 1);
            }
        }
        controls.update();
        renderer.render(scene, camera);
    }

</script>
</html>
