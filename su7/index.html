<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Su7</title>
    <link rel="stylesheet/less" type="text/css" href="css/su7.less">
    <link rel="stylesheet" href="css/dat.gui.css">
    <script src="../js/less.js"></script>
    <script src="../js/jquery-3.1.1.js"></script>
    <script src="../js/gsap/gsap.min.js"></script>
    <script src="js/3d/dat.gui.js"></script>
</head>
<body>

<!-- loading相关 -->
<div class="loading-con">
    <div class="loading">
        <div class="loading-circle"></div>
        <div class="progress"></div>
    </div>
    <div class="loading-complete display-none">
        <p>
            加载完成
            <svg t="1677233206130" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2675" width="24" height="24"><path d="M537.6 102.4c73.5744 0 142.336 20.6848 200.704 56.576 15.872 9.6256 16.7936 23.1424 2.9696 40.5504-14.08 16.2816-43.008 13.2608-86.8352-9.216l-0.0512 0.0512a318.1568 318.1568 0 1 0 104.8064 524.3904h0.3584c19.456-26.7776 40.5504-40.192 63.1296-40.2432l6.8096 0.4096c24.064 4.4032 30.4128 16.6912 19.0464 36.864l0.2048-0.3584-0.1536 0.1536-0.0512 0.2048h-0.1024l-7.936 10.5984A384 384 0 1 1 537.6 102.4z m332.288 201.0112a33.28 33.28 0 0 1 0 47.104l-276.48 276.48a31.2832 31.2832 0 0 1-0.512 0.4608l-3.584 3.584a30.72 30.72 0 0 1-43.4176 0l-1.8432-1.792-0.4096-0.512-135.3216-135.2704a30.72 30.72 0 0 1 0-43.4176l3.584-3.584a30.72 30.72 0 0 1 43.4688 0l112.2304 112.128 255.232-255.1808a33.28 33.28 0 0 1 47.104 0z" fill="#ffffff" p-id="2676"></path></svg>
        </p>
    </div>
</div>

<section class="su7">
    <div class="su7-con"></div>

    <div class="buttons">
        <div class="button-item" id="tunnel">Tunnel</div>
        <div class="button-item" id="car-body">Body</div>
        <div class="button-item" id="wind-drag">Wind Drag</div>
        <div class="button-item" id="radar">雷达</div>
    </div>
</section>

<div class="dialog">
    <h3>请将设备横置</h3>
</div>
</body>

<script type="importmap">
    {
        "imports": {
                "three": "./js/3d/three.module.js"
        }
    }
</script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls }  from './js/3d/OrbitControls.js';
    import resources from "./js/config/resources.js";
    import Loader from './js/loaders/loadResource.js'

    const loader = new Loader()
    const buttonMap = {
        tunnel: '1',
        body: '2',
        windDrag: '3',
        radar: '4'
    }

    const elementSu7 = document.querySelector('.su7');
    const dialog = document.querySelector('.dialog');
    const scene = new THREE.Scene();
    const clock = new THREE.Clock();

    const radarVertexArray = [];
    const radarMeshArray = [];
    const vec3Zero = new THREE.Vector3(0,0.6,0)
    const group = new THREE.Group();
    const radarGroup = new THREE.Group();

    let fovDefault = 60;
    let fovTarget = 75;
    let buttonSelect = buttonMap.tunnel
    let mixer,mixer_other;
    let isLandscapeScreen = false;
    let isIntoScene = false;
    let isRadar = false;
    let runTunnel = false;
    let nameToMeshDic = {};
    let loadMap = {};
    let hemisphereLight, dLight, groundLoader, cubeRenderTarget, cubeCamera;
    let loadIndex = 0;


    const camera = new THREE.PerspectiveCamera( fovDefault, window.innerWidth / window.innerHeight, 0.1, 500 );
    camera.position.set( 1.53,  3.78, -1.46);

    // const gui = new GUI()
    // gui.add(camera.position, 'x', -10, 10)
    // gui.add(camera.position, 'y', -10, 10)
    // gui.add(camera.position, 'z', -10, 10)

    scene.background = new THREE.Color( 0x000000 );
    scene.fog = new THREE.Fog( 0x000000, 4, 40 );

    // const rgbeLoader = new RGBELoader();
    // rgbeLoader.load('../img/sky.hdr',(texture)=>{
    //     scene.background = texture;
    //     scene.environment = texture;
    //     texture.mapping = THREE.EquirectangularReflectionMapping;
    // });
    // scene.add(group);


    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    $('.su7-con').append( renderer.domElement );


    window.addEventListener('resize', onWindowResized);

    // cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
    // cubeRenderTarget.texture.type = THREE.HalfFloatType;
    // cubeCamera = new THREE.CubeCamera(0.1, 200, cubeRenderTarget);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target = new THREE.Vector3(0, 1, 0);

    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    controls.enableZoom = false;

    controls.enablePan = false;

    controls.maxDistance = 3.5;
    controls.minDistance = 3.5;

    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI / 2;

    loader.load(resources)

    loader.onFileLoaded((name,res) => {
        const result = loaderCustom(name)(res)
        if (name !== 'sceneLoad'){
            scene.add(result)
        }
        loadMap[name] = result

        const value = loader.totalSuccess / loader.total * 100
        progressText(value)
    })

    loader.onLoadEnd(()=>{
        loadMap['roadMesh'].visible = false
        loadMap['otherCarLoad'].visible = false

        initHemisphereLight();
        initLight();
        initGrid();

        buttOnClick();

        intoScene()
        // cubeBoxGeometry()
    })

    function loaderCustom(type){
        const StrategyMap = {
            'sceneLoad': (texture)=>{
                    scene.background = texture;
                    scene.environment = texture;
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                },
            'roadMesh': (banMa)=>{
                banMa.wrapS = THREE.RepeatWrapping;
                banMa.wrapT = THREE.RepeatWrapping;
                banMa.repeat.set(1, 6);

                const PlaneGeometry =  new THREE.PlaneGeometry(15,100)
                const MeshStandardMaterial =  new THREE.MeshStandardMaterial({
                    map:banMa,
                    color: '#343434'
                })
                const roadMesh = new THREE.Mesh(
                    PlaneGeometry,
                    MeshStandardMaterial
                )
                roadMesh.rotation.x = - Math.PI / 2;
                roadMesh.position.y = -0.1;
                return roadMesh
            } ,
            'otherCarLoad': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if (['otherCar01','otherCar02'].includes(child.name)){
                        nameToMeshDic[child.name] = child
                        child.userData['originPos'] = child.position.clone();
                    }
                })
                const animations = gltf.animations;
                if (animations && animations.length){
                    mixer_other = new THREE.AnimationMixer(gltf.scene);
                    for (let i = 0; i< animations.length; i++){
                        const action = mixer_other.clipAction(animations[i]);
                        action.play();
                    }
                }
                return gltf.scene
            },
            'carLoad': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if(child.name === 'radar' || child.name === '车身'){
                        nameToMeshDic[child.name] = child
                    }
                    // if (child.type === 'Meth'){
                    //     child.material.envMap = cubeRenderTarget.texture;
                    //     child.material.envMapIntensity = 2;
                    //     child.castShadow = true;
                    //     child.receiveShadow = true;
                    // }
                    // child.traverse((item)=>{
                    //     if (item.type === 'Mesh'){
                    //         item.material.envMapIntensity = 5
                    //     }
                    // })


                })
                const animations = gltf.animations;
                if (animations && animations.length){
                    mixer = new THREE.AnimationMixer(gltf.scene);
                    for (let i = 0; i< animations.length; i++){
                        const action = mixer.clipAction(animations[i]);
                        action.play();
                    }

                }
                return gltf.scene
            },
            'carCurveLoad': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    nameToMeshDic['carCurve'] = child
                    if (child.name === 'xiedu'){
                        child.material.opacity = 0
                    }

                })
                return gltf.scene
            },
            'tunnelLoader': (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if (child.name === 'tunnel'){
                        child.material.opacity = 0
                    }
                    nameToMeshDic['tunnel'] = child
                })
                return gltf.scene
            },
        }
        return StrategyMap[type]
    }

    function updateLoadingProgress(progress,loading_text){
        progress && (progress.textContent = loading_text);
    }
    function progressText(percent){
        const text =  `加载场景模型: ${percent} %`
        const progress = document.querySelector('.progress')

        updateLoadingProgress(progress, text)

    }

    function intoScene(){
        const loading_complete = document.querySelector('.loading-complete')
        const loading_con = document.querySelector('.loading-con')
        loading_complete.classList.remove("display-none");
        loading_con.classList.add("hide-loading");

        loading_con.addEventListener('animationend', function() {
            loading_con.classList.add("display-none")
        });
        gsap.to(camera.position,{
            x: 3.99,
            y: 0.55,
            z: 0,
            duration: 1,
            ease: 'power5.inOut'
        })

    }

    function cubeBoxGeometry(){
        const cubeSize = 1
        const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        const cubeMat = new THREE.MeshBasicMaterial({ color: '#5af62e' });
        const mesh = new THREE.Mesh(cubeGeo, cubeMat);
        mesh.castShadow = true // 投射阴影
        mesh.receiveShadow = true // 接受阴影
        mesh.position.y = 1;
        scene.add(mesh);
    }

    function initHemisphereLight () {
        hemisphereLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 3 );
        hemisphereLight.position.set( 0, 20, 0 );
        scene.add( hemisphereLight );


        const light =  new THREE.DirectionalLight(0xffffff,1);
        light.position.set(0,0,10);
        scene.add( light );

        const light1 =  new THREE.DirectionalLight(0xffffff,1);
        light.position.set(0,0,-10);
        scene.add( light1 );

    }

    function initLight(){
        dLight = new THREE.DirectionalLight( '#ffffff', 4 );
        dLight.position.set( 0, 5, -5 );
        dLight.castShadow = true;
        dLight.shadow.camera.top = 2;
        dLight.shadow.camera.bottom = - 2;
        dLight.shadow.camera.left = - 2;
        dLight.shadow.camera.right = 2;
        scene.add( dLight );

    }

    function initGrid(){
        const grid = new THREE.GridHelper( 40, 20, 0xdddddd, 0xdddddd );
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add( grid )
    }

    function buttOnClick(){
        const tunnel = document.getElementById('tunnel');
        const carBody = document.getElementById('car-body');
        const windDrag = document.getElementById('wind-drag');
        const radar = document.getElementById('radar');
        tunnel.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.tunnel
        }
        carBody.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.body
            const carCurve = nameToMeshDic['carCurve']

            gsap.to(carCurve.material.map.offset,{
                y: -2,
                duration: fovDefault,
                repeat: -1,
                ease: 'none'
            })
        }
        windDrag.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.windDrag

        }

        radar.onclick = function (){
            recoverState()
            buttonSelect = buttonMap.radar
            isRadar = true;
            loadMap['roadMesh'].visible = true
            loadMap['otherCarLoad'].visible = true
            radarGroup.visible = true

            nameToMeshDic['cameraOutRadar'] && nameToMeshDic['cameraOutRadar'].kill()
            nameToMeshDic['controlsTween'] && nameToMeshDic['controlsTween'].kill()
            nameToMeshDic['cameraToRadar'] = gsap.to(camera.position,{
                x: 0.01,
                y: 4.17,
                z: -2.44,
                duration: 1
            })
            nameToMeshDic['controlsTween'] = gsap.to(controls,{
                maxDistance: 6,
                minDistance: 6,
                duration: 1,
                repeat: 0,
                ease: 'none',
                onUpdate: () => {
                    camera.updateProjectionMatrix();
                }
            })
            setRadarMesh();
            setOtherCar();
        }
    }

    window.addEventListener('mousedown',(e)=>{
        if (!(e.target instanceof HTMLCanvasElement)){
            return
        }
        if (e.button === 0) {
            if (buttonSelect === buttonMap.tunnel){
                const tunnel = nameToMeshDic['tunnel']

                runTunnel = true
                nameToMeshDic['cameraTween'] && nameToMeshDic['cameraTween'].kill()
                tunnel.userData['tunnelTween'] && tunnel.userData['tunnelTween'].kill()
                tunnel.userData['tunnelOpacityTween'] && tunnel.userData['tunnelOpacityTween'].kill()

                nameToMeshDic['cameraTween'] = gsap.to(camera, {
                    fov: fovTarget,
                    duration: 1,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });

                tunnel.userData['tunnelTween'] = gsap.to(tunnel.material.map.offset,{
                    x: tunnel.material.map.offset.x + 1,
                    duration: 2,
                    repeat: -1,
                    ease: 'none'
                })

                tunnel.userData['tunnelOpacityTween'] = gsap.to(tunnel.material, {
                    opacity: 1,
                    duration: 2,
                    repeat: 0,
                    ease: 'none'
                });
            }
            if (buttonSelect === buttonMap.body) {
                const carCurve = nameToMeshDic['carCurve']

                carCurve.userData['carCurveOpacityTween'] && carCurve.userData['carCurveOpacityTween'].kill()
                carCurve.userData['carCurveOpacityTween'] = gsap.to(carCurve.material, {
                    opacity: 1,
                    repeat: 0,
                    duration: 4,
                    ease: 'none',
                });
            }
        }

    })
    window.addEventListener('mouseup',(e)=>{
        if (!(e.target instanceof HTMLCanvasElement)){
            return
        }
        if (e.button === 0){
            if (buttonSelect === buttonMap.tunnel){
                const tunnel = nameToMeshDic['tunnel']

                runTunnel = false
                nameToMeshDic['cameraTween'] && nameToMeshDic['cameraTween'].kill()
                tunnel.userData['tunnelOpacityTween'] && tunnel.userData['tunnelOpacityTween'].kill()

                nameToMeshDic['cameraTween'] = gsap.to(camera, {
                    fov: fovDefault,
                    duration: 1,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });
                tunnel.userData['tunnelOpacityTween'] = gsap.to(tunnel.material, {
                    opacity: 0,
                    repeat: 0,
                    duration: 1,
                    ease: 'none',
                    onComplete: () => {
                        tunnel.userData['tunnelTween'] && tunnel.userData['tunnelTween'].kill()
                    }
                });
            }

            if (buttonSelect === buttonMap.body){
                const carCurve = nameToMeshDic['carCurve']

                carCurve.userData['carCurveOpacityTween'] && carCurve.userData['carCurveOpacityTween'].kill()
                carCurve.userData['carCurveOpacityTween'] = gsap.to(carCurve.material, {
                    opacity: 0,
                    repeat: 0,
                    duration: 1,
                    ease: 'none'
                });
            }
        }

    })
    window.addEventListener('scroll', () => {
        if (isElementInViewport(elementSu7) && isMobile()) {
            if (!isLandscapeScreen){
                dialog.classList.add('show-dialog')
            }else {
                dialog.classList.remove('show-dialog')
            }
        }else {
            dialog.classList.remove('show-dialog')
        }
    });
    window.addEventListener('orientationchange', function() {
        isLandscapeScreen = !(screen.orientation.angle === 90 || screen.orientation.angle === 270);
    });

    function recoverState(){
        nameToMeshDic['cameraToRadar'] && nameToMeshDic['cameraToRadar'].kill();
        nameToMeshDic['controlsTween'] && nameToMeshDic['controlsTween'].kill();

        isRadar = false;
        loadMap['roadMesh'].visible = false
        loadMap['otherCarLoad'].visible = false
        radarGroup.visible = false
        nameToMeshDic['cameraOutRadar'] = gsap.to(camera.position,{
            x: 3.99,
            y: 0.55,
            z: 0,
            duration: 1
        })
        nameToMeshDic['controlsTween'] = gsap.to(controls,{
            maxDistance: 3.5,
            minDistance: 3.5,
            duration: 1,
            repeat: 0,
            ease: 'power5.inOut',
            onUpdate: () => {
                camera.updateProjectionMatrix();
            }
        })
    }
    function setRadarMesh(){
        const child = nameToMeshDic['radar'];
        const boxGeo = new THREE.BoxGeometry(0.02,0.01,0.1);
        const positionAttributes = child.geometry.getAttribute('position');

        for (let i = 0; i< positionAttributes.count; i++){
            const vec3 = new THREE.Vector3();
            vec3.fromBufferAttribute(positionAttributes,i);
            radarVertexArray.push(vec3);
        }
        radarGroup.visible = true
        if (!radarMeshArray.length){
            scene.add(radarGroup);
            radarGroup.position.set(0, 0.5, 0);
            for (let k = 0; k < 6; k++){
                for (let i = 0; i< radarVertexArray.length; i++){
                    const boxMat = new THREE.MeshBasicMaterial({color: 0xffffff, depthTest: false});
                    const boxMesh = new THREE.Mesh(boxGeo,boxMat);
                    boxMesh.position.copy(radarVertexArray[i]);
                    boxMesh.visible = false;
                    radarGroup.add(boxMesh);

                    radarMeshArray.push(boxMesh);
                    boxMesh.lookAt(vec3Zero);
                    boxMesh.userData['originPos'] =  boxMesh.position.clone();
                    boxMesh.translateZ(-5);
                    boxMesh.userData['targetPos'] =  boxMesh.position.clone();
                    boxMesh.translateZ(5);

                    if (k === 0){
                        boxMesh.userData['delay'] = 0
                    }else if (k === 1){
                        boxMesh.userData['delay'] = 0.5
                    }else if (k === 2){
                        boxMesh.userData['delay'] = 1
                    }else if (k === 3){
                        boxMesh.userData['delay'] = 2
                    }else if (k === 4){
                        boxMesh.userData['delay'] = 2.5
                    }else if (k === 5){
                        boxMesh.userData['delay'] = 3
                    }
                }
                for (let j = 0; j< radarMeshArray.length; j++){
                    gsap.to(radarMeshArray[j].position,{
                        x: radarMeshArray[j].userData['targetPos'].x,
                        y: radarMeshArray[j].userData['targetPos'].y,
                        z: radarMeshArray[j].userData['targetPos'].z,
                        duration: 4,
                        delay: radarMeshArray[j].userData['delay'],
                        repeat: -1,
                        ease: 'none',
                        onStart:()=>{
                            radarMeshArray[j].visible = true;
                        }
                    })
                }
            }
        }
    }

    function setOtherCar(){
        const otherCar01 = nameToMeshDic['otherCar01'];
        const otherCar02 = nameToMeshDic['otherCar02'];

        otherCar01.userData['otherCar01Tween'] && otherCar01.userData['otherCar01Tween'].kill();
        otherCar01.userData['otherCar02Tween'] && otherCar01.userData['otherCar02Tween'].kill();

        gsap.to(loadMap['roadMesh'].material.map.offset,{
            y:loadMap['roadMesh'].material.map.offset.y - 1,
            duration: 3,
            repeat: -1,
            ease: 'none'
        })

        otherCar01.position.copy(otherCar01.userData['originPos']);
        otherCar01.userData['otherCar01Tween'] = gsap.to(otherCar01.position,{
            z: 20,
            duration: 9,
            repeat: -1
        })

        otherCar02.position.copy(otherCar02.userData['originPos']);
        otherCar01.userData['otherCar02Tween'] = gsap.to(otherCar02.position,{
            z: -20,
            duration: 10,
            repeat: -1
        })

    }

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }

    function isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        return (
            rect.top <= (window.innerHeight - 200 || document.documentElement.clientHeight -200)
        )
    }

    function isMobile() {
        const reg = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
        return reg.test(navigator.userAgent);
    }

    let temp01 = 0;
    let temp02 = 0;
    let meshScale = 0;
    let temp = 1.5
    function renderLoop(){
        // if (groundLoader){
        //     groundLoader.visible = false;
        //     cubeCamera.position.copy(camera.position);
        //     cubeCamera.position.y *= -1;
        //     cubeCamera.update(renderer,scene);
        //     groundLoader.visible = true;
        // }

        renderer.setSize( window.innerWidth, window.innerHeight );
        if (mixer && (isRadar || runTunnel)) {
            mixer.update(clock.getDelta());
        }

        for (let i = 0; i < radarMeshArray.length; i++){
            temp01 = nameToMeshDic['otherCar01'].position.distanceTo(radarMeshArray[i].position);
            temp02 = nameToMeshDic['otherCar02'].position.distanceTo(radarMeshArray[i].position);

            if (temp01 < temp || temp02 < temp){
                radarMeshArray[i].material.color.setHex(0x00ff00);

                if (temp01 < temp){
                    meshScale = 3 - temp01 > 1 ? 3 - temp01 : 1;
                    radarMeshArray[i].scale.setZ(meshScale)
                }

                if (temp02 < temp){
                    meshScale = 3 - temp02 > 1 ? 3 - temp02 : 1;
                    radarMeshArray[i].scale.setZ(meshScale)
                }
            }else {
                radarMeshArray[i].material.color.setHex(0xffffff);
                radarMeshArray[i].scale.set(1, 1, 1);
            }
        }
        controls.update();
        renderer.render(scene, camera);
    }

</script>
</html>
