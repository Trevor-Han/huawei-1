<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Su7</title>
    <link rel="stylesheet/less" type="text/css" href="css/su7.less">
    <link rel="stylesheet" href="css/dat.gui.css">
    <script src="../js/less.js"></script>
    <script src="../js/jquery-3.1.1.js"></script>
    <script src="../js/gsap/gsap.min.js"></script>
    <script src="js/3d/dat.gui.js"></script>
</head>
<body>
<section class="su7">
    <div class="su7-con"></div>

    <div class="buttons">
        <div class="button-item" id="tunnel">Tunnel</div>
        <div class="button-item" id="car-body">Body</div>
        <div class="button-item" id="wind-drag">Wind Drag</div>
        <div class="button-item" id="radar">雷达</div>
    </div>
</section>

<div class="dialog">
    <h3>请将设备横置</h3>
</div>
</body>

<script type="importmap">
    {
        "imports": {
                "three": "./js/3d/three.module.js"
        }
    }
</script>
<script type="module">
    import * as THREE from 'three';
    import { RGBELoader } from './js/loaders/RGBELoader.js';
    import { GLTFLoader }  from './js/loaders/GLTFLoader.js';
    import { OrbitControls }  from './js/3d/OrbitControls.js';

    const buttonMap = {
        tunnel: '1',
        body: '2',
        windDrag: '3',
        radar: '4'
    }

    const elementSu7 = document.querySelector('.su7');
    const dialog = document.querySelector('.dialog');
    const scene = new THREE.Scene();
    const clock = new THREE.Clock();

    const radarVertexArray = [];
    const radarMeshArray = [];
    const vec3Zero = new THREE.Vector3(0,0.6,0)
    const group = new THREE.Group();
    // const roadGroup = new THREE.Group();
    // const otherGroup = new THREE.Group();
    // const carGroup = new THREE.Group();
    const radarGroup = new THREE.Group();

    let buttonSelect = buttonMap.tunnel
    let mixer,mixer_other;
    let isLandscapeScreen = false;
    let isRadar = false;
    let runTunnel = false;
    let nameToMeshDic = {};
    let loadMap = {};
    let hemisphereLight, dLight, groundLoader, cubeRenderTarget, cubeCamera;
    let loadIndex = 0;


    const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 500 );
    camera.position.set( 3.99,  0.55, 0);

    // const gui = new GUI()
    // gui.add(camera.position, 'x', -10, 10)
    // gui.add(camera.position, 'y', -10, 10)
    // gui.add(camera.position, 'z', -10, 10)

    scene.background = new THREE.Color( 0x000000 );
    scene.fog = new THREE.Fog( 0x000000, 4, 40 );

    // const rgbeLoader = new RGBELoader();
    // rgbeLoader.load('../img/sky.hdr',(texture)=>{
    //     scene.background = texture;
    //     scene.environment = texture;
    //     texture.mapping = THREE.EquirectangularReflectionMapping;
    // });
    // scene.add(group);


    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setAnimationLoop(renderLoop);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    $('.su7-con').append( renderer.domElement );


    window.addEventListener('resize', onWindowResized);

    // cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
    // cubeRenderTarget.texture.type = THREE.HalfFloatType;
    // cubeCamera = new THREE.CubeCamera(0.1, 200, cubeRenderTarget);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target = new THREE.Vector3(0, 1, 0);

    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    controls.enableZoom = false;

    controls.enablePan = false;

    controls.maxDistance = 3.5;
    controls.minDistance = 3.5;

    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI / 2;
    // controls.enableZoom = false
    // controls.enableRotate = false

    window.addEventListener('scroll', () => {
        if (isElementInViewport(elementSu7) && isMobile()) {
            if (!isLandscapeScreen){
                dialog.classList.add('show-dialog')
            }else {
                dialog.classList.remove('show-dialog')
            }
        }else {
            dialog.classList.remove('show-dialog')
        }
    });

    window.addEventListener('orientationchange', function() {
        isLandscapeScreen = !(screen.orientation.angle === 90 || screen.orientation.angle === 270);
    });


    init();

    function cubeBoxGeometry(){
        const cubeSize = 1
        const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        const cubeMat = new THREE.MeshBasicMaterial({ color: '#5af62e' });
        const mesh = new THREE.Mesh(cubeGeo, cubeMat);
        mesh.castShadow = true // 投射阴影
        mesh.receiveShadow = true // 接受阴影
        mesh.position.y = 1;
        scene.add(mesh);
    }


    function initOtherCarLoader(){
        const gltfLoader = new GLTFLoader();
        return new Promise(resolve => {
            gltfLoader.load('../models/gltf/otherCar.glb',async (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if (['otherCar01','otherCar02'].includes(child.name)){
                        nameToMeshDic[child.name] = child
                        child.userData['originPos'] = child.position.clone();
                    }
                })
                const animations = gltf.animations;
                if (animations && animations.length){
                    mixer_other = new THREE.AnimationMixer(gltf.scene);
                    for (let i = 0; i< animations.length; i++){
                        const action = mixer_other.clipAction(animations[i]);
                        action.play();
                    }

                }
                resolve(gltf.scene);
            })
        })
    }

    function initGltfLoader(){
        const gltfLoader = new GLTFLoader();
        return new Promise(resolve => {
            gltfLoader.load('../models/gltf/su7-car.glb',async (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if(child.name === 'radar' || child.name === '车身'){
                        nameToMeshDic[child.name] = child
                    }
                    // if (child.type === 'Meth'){
                    //     child.material.envMap = cubeRenderTarget.texture;
                    //     child.material.envMapIntensity = 2;
                    //     child.castShadow = true;
                    //     child.receiveShadow = true;
                    // }
                    // child.traverse((item)=>{
                    //     if (item.type === 'Mesh'){
                    //         item.material.envMapIntensity = 5
                    //     }
                    // })


                })
                const animations = gltf.animations;
                if (animations && animations.length){
                    mixer = new THREE.AnimationMixer(gltf.scene);
                    for (let i = 0; i< animations.length; i++){
                        const action = mixer.clipAction(animations[i]);
                        action.play();
                    }

                }
                resolve(gltf.scene);
            })
        })
    }

    function initCarCurveLoader(){
        const gltfLoader = new GLTFLoader();
        return new Promise(resolve => {
            gltfLoader.load('../models/gltf/xiedu.glb',async (gltf)=>{
                gltf.scene.traverse((child)=>{
                    nameToMeshDic['carCurve'] = child
                })
                resolve(gltf.scene);
            })
        })
    }

    function iniTunnelLoader(){
        const gltfLoader = new GLTFLoader();
        return new Promise(resolve => {
            gltfLoader.load('../models/gltf/tunnel.glb',async (gltf)=>{
                gltf.scene.traverse((child)=>{
                    if (child.name === 'tunnel'){
                        child.material.opacity = 0
                    }
                    nameToMeshDic['tunnel'] = child
                })
                resolve(gltf.scene);
            })
        })
    }


    function initRoadMesh(){
        return new Promise(resolve => {
            const banMa = new THREE.TextureLoader().load("../img/banmaxian.jpg");
            banMa.wrapS = THREE.RepeatWrapping;
            banMa.wrapT = THREE.RepeatWrapping;
            banMa.repeat.set(1, 6);

            const PlaneGeometry =  new THREE.PlaneGeometry(15,100)
            const MeshStandardMaterial =  new THREE.MeshStandardMaterial({
                map:banMa,
                color: '#343434'
            })
            const roadMesh = new THREE.Mesh(
                PlaneGeometry,
                MeshStandardMaterial
            )
            roadMesh.rotation.x = - Math.PI / 2;
            roadMesh.position.y = -0.1;
            resolve(roadMesh)
        })
    }

    async function init(){
        if (loadIndex < 100){
            loadIndex++
        }
        const roadMesh = await initRoadMesh();
        const otherCarLoad = await initOtherCarLoader();
        const carLoad = await initGltfLoader();
        const carCurveLoad = await initCarCurveLoader();
        const tunnelLoader = await iniTunnelLoader();
        // groundLoader = await initGroundLoader();

        scene.add(roadMesh,otherCarLoad,carLoad,carCurveLoad,tunnelLoader)
        loadMap = {
            'roadMesh': roadMesh,
            'otherCarLoad': otherCarLoad,
            'carLoad': carLoad,
            'carCurveLoad': carCurveLoad,
            'tunnelLoader': tunnelLoader,
        }
        loadMap['roadMesh'].visible = false
        loadMap['otherCarLoad'].visible = false
        loadMap['carCurveLoad'].visible = false

        initHemisphereLight();
        initLight();
        initGrid();

        buttOnClick();
        // cubeBoxGeometry()
        // moveCamera();

    }
    function initHemisphereLight () {
        hemisphereLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 3 );
        hemisphereLight.position.set( 0, 20, 0 );
        scene.add( hemisphereLight );


        const light =  new THREE.DirectionalLight(0xffffff,1);
        light.position.set(0,0,10);
        scene.add( light );

        const light1 =  new THREE.DirectionalLight(0xffffff,1);
        light.position.set(0,0,-10);
        scene.add( light1 );

    }

    function initLight(){
        dLight = new THREE.DirectionalLight( '#ffffff', 4 );
        dLight.position.set( 0, 5, -5 );
        dLight.castShadow = true;
        dLight.shadow.camera.top = 2;
        dLight.shadow.camera.bottom = - 2;
        dLight.shadow.camera.left = - 2;
        dLight.shadow.camera.right = 2;
        scene.add( dLight );

    }


    function initGrid(){
        const grid = new THREE.GridHelper( 40, 20, 0xdddddd, 0xdddddd );
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add( grid )
    }

    function initGroundLoader(){
        return new Promise(resolve => {
            const loader = new THREE.TextureLoader();
            const texture = loader.load("../img/floor_normal.jpg");
            const groundGeometry = new THREE.PlaneGeometry(40, 15);
            const groundMaterial = new THREE.MeshStandardMaterial(
                {
                    side: THREE.DoubleSide,
                    roughness: 0.1,
                    metalness: .4,
                    // envMap: cubeRenderTarget.texture,
                    map: texture
                });

            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = Math.PI * -0.5;
            groundMesh.receiveShadow = true // 接受阴影
            resolve(groundMesh)
        })
    }

    function moveCamera(){
        const target = new THREE.Vector3(0.72,2.00,3.69)
        ScrollTrigger.create({
            trigger: '.su7',
            start: 'center center',
            end: '+=2500',
            pin: true,
            scrub: true,
            animation: gsap.timeline()
                .to(camera.position,{x:target.x, y:target.y, z: target.z})
        })
    }

    function buttOnClick(){
        const tunnel = document.getElementById('tunnel');
        const carBody = document.getElementById('car-body');
        const windDrag = document.getElementById('wind-drag');
        const radar = document.getElementById('radar');
        tunnel.onclick = function (){
            buttonSelect = buttonMap.tunnel
        }
        carBody.onclick = function (){
            buttonSelect = buttonMap.body
            const carCurve = nameToMeshDic['carCurve']

            recoverState()
            loadMap['carCurveLoad'].visible = true

            gsap.to(carCurve.material.map.offset,{
                y: -2,
                duration: 60,
                repeat: -1,
                ease: 'none'
            })
        }
        windDrag.onclick = function (){
            buttonSelect = buttonMap.windDrag
            recoverState()
        }

        radar.onclick = function (){
            buttonSelect = buttonMap.radar
            isRadar = true;
            loadMap['roadMesh'].visible = true
            loadMap['otherCarLoad'].visible = true
            loadMap['carCurveLoad'].visible = false
            radarGroup.visible = true

            if (nameToMeshDic['cameraOutRadar']){
                nameToMeshDic['cameraOutRadar'].kill();
            }
            nameToMeshDic['cameraToRadar'] = gsap.to(camera.position,{
                x: 0.01,
                y: 4.17,
                z: -2.44,
                duration: 1
            })
            setRadarMesh();
            setOtherCar();
        }
    }

    window.addEventListener('mousedown',(e)=>{
        if (!(e.target instanceof HTMLCanvasElement)){
            return
        }
        if (e.button === 0) {
            if (buttonSelect === buttonMap.tunnel){
                const tunnel = nameToMeshDic['tunnel']

                runTunnel = true
                tunnel.userData['cameraTween'] && tunnel.userData['cameraTween'].kill()
                tunnel.userData['tunnelTween'] && tunnel.userData['tunnelTween'].kill()
                tunnel.userData['tunnelOpacityTween'] && tunnel.userData['tunnelOpacityTween'].kill()

                tunnel.userData['cameraTween'] = gsap.to(camera, {
                    fov: 75,
                    duration: 1,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });

                tunnel.userData['tunnelTween'] = gsap.to(tunnel.material.map.offset,{
                    x: tunnel.material.map.offset.x + 1,
                    duration: 2,
                    repeat: -1,
                    ease: 'none'
                })

                tunnel.userData['tunnelOpacityTween'] = gsap.to(tunnel.material, {
                    opacity: 1,
                    duration: 2,
                    repeat: 0,
                    ease: 'none'
                });
            }
            if (buttonSelect === buttonMap.body) {
                const carCurve = nameToMeshDic['carCurve']

                loadMap['carCurveLoad'].visible = true
                if (carCurve.userData['carCurveOpacityTween']){
                    carCurve.userData['carCurveOpacityTween'].kill()
                }
                carCurve.userData['carCurveOpacityTween'] = gsap.to(carCurve.material, {
                    opacity: 1,
                    repeat: 0,
                    duration: 4,
                    ease: 'none',
                });
            }
        }

    })
    window.addEventListener('mouseup',(e)=>{
        if (!(e.target instanceof HTMLCanvasElement)){
            return
        }
        if (e.button === 0){
            if (buttonSelect === buttonMap.tunnel){
                const tunnel = nameToMeshDic['tunnel']

                runTunnel = false
                tunnel.userData['cameraTween'] && tunnel.userData['cameraTween'].kill()
                tunnel.userData['tunnelOpacityTween'] && tunnel.userData['tunnelOpacityTween'].kill()

                tunnel.userData['cameraTween'] = gsap.to(camera, {
                    fov: 60,
                    duration: 1,
                    repeat: 0,
                    ease: 'power5.inOut',
                    onUpdate: () => {
                        camera.updateProjectionMatrix();
                    }
                });
                tunnel.userData['tunnelOpacityTween'] = gsap.to(tunnel.material, {
                    opacity: 0,
                    repeat: 0,
                    duration: 1,
                    ease: 'none',
                    onComplete: () => {
                        tunnel.userData['tunnelTween'] && tunnel.userData['tunnelTween'].kill()
                    }
                });
            }

            if (buttonSelect === buttonMap.body){
                const carCurve = nameToMeshDic['carCurve']

                if (carCurve.userData['carCurveOpacityTween']){
                    carCurve.userData['carCurveOpacityTween'].kill()
                }
                carCurve.userData['carCurveOpacityTween'] = gsap.to(carCurve.material, {
                    opacity: 0,
                    repeat: 0,
                    duration: 1,
                    ease: 'none',
                    onComplete: () => {
                        loadMap['carCurveLoad'].visible = false;
                    }
                });
            }
        }

    })

    function recoverState(){
        if (nameToMeshDic['cameraToRadar']){
            nameToMeshDic['cameraToRadar'].kill();
        }
        if (nameToMeshDic['carCurve'].userData['carCurveOpacityTween']){
            nameToMeshDic['carCurve'].userData['carCurveOpacityTween'].kill();
        }

        isRadar = false;
        loadMap['roadMesh'].visible = false
        loadMap['otherCarLoad'].visible = false
        loadMap['carCurveLoad'].visible = false
        radarGroup.visible = false
        nameToMeshDic['cameraOutRadar'] = gsap.to(camera.position,{
            x: 3.99,
            y: 0.55,
            z: 0,
            duration: 1
        })
    }
    function setRadarMesh(){
        const child = nameToMeshDic['radar'];
        const boxGeo = new THREE.BoxGeometry(0.02,0.01,0.1);
        const positionAttributes = child.geometry.getAttribute('position');

        for (let i = 0; i< positionAttributes.count; i++){
            const vec3 = new THREE.Vector3();
            vec3.fromBufferAttribute(positionAttributes,i);
            radarVertexArray.push(vec3);
        }
        radarGroup.visible = true
        if (!radarMeshArray.length){
            scene.add(radarGroup);
            radarGroup.position.set(0, 0.5, 0);
            for (let k = 0; k < 6; k++){
                for (let i = 0; i< radarVertexArray.length; i++){
                    const boxMat = new THREE.MeshBasicMaterial({color: 0xffffff, depthTest: false});
                    const boxMesh = new THREE.Mesh(boxGeo,boxMat);
                    boxMesh.position.copy(radarVertexArray[i]);
                    boxMesh.visible = false;
                    radarGroup.add(boxMesh);

                    radarMeshArray.push(boxMesh);
                    boxMesh.lookAt(vec3Zero);
                    boxMesh.userData['originPos'] =  boxMesh.position.clone();
                    boxMesh.translateZ(-3);
                    boxMesh.userData['targetPos'] =  boxMesh.position.clone();
                    boxMesh.translateZ(3);

                    if (k === 0){
                        boxMesh.userData['delay'] = 0
                    }else if (k === 1){
                        boxMesh.userData['delay'] = 0.5
                    }else if (k === 2){
                        boxMesh.userData['delay'] = 1
                    }else if (k === 3){
                        boxMesh.userData['delay'] = 2
                    }else if (k === 4){
                        boxMesh.userData['delay'] = 2.5
                    }else if (k === 5){
                        boxMesh.userData['delay'] = 3
                    }
                }
                for (let j = 0; j< radarMeshArray.length; j++){
                    gsap.to(radarMeshArray[j].position,{
                        x: radarMeshArray[j].userData['targetPos'].x,
                        y: radarMeshArray[j].userData['targetPos'].y,
                        z: radarMeshArray[j].userData['targetPos'].z,
                        duration: 4,
                        delay: radarMeshArray[j].userData['delay'],
                        repeat: -1,
                        ease: 'none',
                        onStart:()=>{
                            radarMeshArray[j].visible = true;
                        }
                    })
                }
            }
        }
    }

    function setOtherCar(){
        const otherCar01 = nameToMeshDic['otherCar01'];
        const otherCar02 = nameToMeshDic['otherCar02'];

        // otherGroup.visible = true;
        // otherCar01.visible = true;
        // otherCar02.visible = true;

        if (otherCar01.userData['otherCar01Tween']){
            otherCar01.userData['otherCar01Tween'].kill();
        }
        if (otherCar01.userData['otherCar02Tween']){
            otherCar01.userData['otherCar02Tween'].kill();
        }

        gsap.to(loadMap['roadMesh'].material.map.offset,{
            y:loadMap['roadMesh'].material.map.offset.y - 1,
            duration: 3,
            repeat: -1,
            ease: 'none'
        })

        otherCar01.position.copy(otherCar01.userData['originPos']);
        otherCar01.userData['otherCar01Tween'] = gsap.to(otherCar01.position,{
            z: 10,
            duration: 9,
            repeat: -1
        })

        otherCar02.position.copy(otherCar02.userData['originPos']);
        otherCar01.userData['otherCar02Tween'] = gsap.to(otherCar02.position,{
            z: -10,
            duration: 10,
            repeat: -1
        })

    }

    function onWindowResized() {
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

    }

    function isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        return (
            rect.top <= (window.innerHeight - 200 || document.documentElement.clientHeight -200)
        )
    }

    function isMobile() {
        const reg = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
        return reg.test(navigator.userAgent);
    }

    let temp01 = 0;
    let temp02 = 0;
    let meshScale = 0;
    let temp = 1.5
    function renderLoop(){
        // if (groundLoader){
        //     groundLoader.visible = false;
        //     cubeCamera.position.copy(camera.position);
        //     cubeCamera.position.y *= -1;
        //     cubeCamera.update(renderer,scene);
        //     groundLoader.visible = true;
        // }

        renderer.setSize( window.innerWidth, window.innerHeight );
        if (mixer && (isRadar || runTunnel)) {
            mixer.update(clock.getDelta());
        }

        for (let i = 0; i < radarMeshArray.length; i++){
            temp01 = nameToMeshDic['otherCar01'].position.distanceTo(radarMeshArray[i].position);
            temp02 = nameToMeshDic['otherCar02'].position.distanceTo(radarMeshArray[i].position);

            if (temp01 < temp || temp02 < temp){
                radarMeshArray[i].material.color.setHex(0x00ff00);

                if (temp01 < temp){
                    meshScale = 3 - temp01 > 1 ? 3 - temp01 : 1;
                    radarMeshArray[i].scale.setZ(meshScale)
                }

                if (temp02 < temp){
                    meshScale = 3 - temp02 > 1 ? 3 - temp02 : 1;
                    radarMeshArray[i].scale.setZ(meshScale)
                }
            }else {
                radarMeshArray[i].material.color.setHex(0xffffff);
                radarMeshArray[i].scale.set(1, 1, 1);
            }
        }
        controls.update();
        renderer.render(scene, camera);
    }

</script>
</html>
